#!/bin/python

import argparse
import collections
import docker
import json
import os
import re
import stat
import subprocess
import time

import abc

class IEnvironment():
  """An interface for environment type classes.

  In general you should derive (directly or indirectly) your environment type
  class from the Environment class because it provides a lot of useful defaults
  (especially implements the whole IEnvironment iterface).
  Anyway, if you really want to write your environment type class from scratch, 
  it will be sufficient if your class implements the IEnvironment interface.
  """
  __metaclass__ = abc.ABCMeta

  @abc.abstractmethod
  def __init__(self, conf, owner): 
    """Environment constructor

    If you derive your class from other, please remember to call a parent 
    constructor!

    Args:
      conf (dict): Dictionary with a configuration to process
      owner (boolean): Indicates if you have rights to access environment files.
        If you don't, you shouldn't check e.g. for the existence of paths in 
        the host (because such checks will always fail).
    """
    pass
  
  @abc.abstractmethod
  def check(self, duplDomains, duplPorts, duplNames, names): 
    """Cheks environment for conflicts and reports them.

    For (at least) 99% of cases class Environment provides a right
    implementation for this method, so please just derive 

    For (at least) 99% of cases class Environment provides a right 
    implementation of this method, so please just derive (directly or 
    indirectly) your class from the Environment one.

    If you really want to implement it on yourself, please remember to set the
    ``ready`` object property to ``False`` if the check will fail.

    Args:
      duplDomains (list): List of duplicated domains.
      duplPorts (list): List of duplicated host ports.
      duplNames (list): List of duplicated environment names.
      names (list): List of all defined environment names. 
        Useful to check e.g. if all links point to existing environments.
    """
    pass
  
  @abc.abstractmethod
  def buildImage(self, verbose): 
    """Runs 'docker build'
    
    For (at least) 99% of cases class Environment provides a right 
    implementation of this method, so please just derive (directly or 
    indirectly) your class from the Environment one.

    Args:
      verbose (boolean): If method should produce a verbose output.
    """
    pass
  
  @abc.abstractmethod
  def runContainer(self, verbose): 
    """Runs 'docker run'

    For (at least) 99% of cases class Environment provides a right 
    implementation of this method, so please just derive (directly or 
    indirectly) your class from the Environment one.
    Implementation profided in the Environment class relies on the
    ``getDockerOpts()`` method to obtain all parameters to be passed to 
    "docker run", so if you need to adjust these parameters, override
    ``getDockerOpts()`` rather the ``runContainer()``.

    If you really want to implement it yourself, please remember to:
    - check, if the ``ready`` property is set to ``True`` before spawning 
      the container;
    - remove a previous instance of a container (with its volumes);
    - run ``docker-mount-volumes containerName`` after container creation.

    Args:
      verbose (boolean): If method should produce a verbose output.
    """
    pass
  
  @abc.abstractmethod
  def runHooks(self, verbose):
    """Adjusts container after it was created.

    A docker image provides all the stuff which is common for every instance
    of an environment type but typically there are also many things which
    should be "personalized" for every instance (user and group to run
    application in guest, ServerName in Apache config in guest, etc.).
    This method provides a way to do that. 
    It is always invoked just after ``runContainer()``

    If you derive your class form other, please check carefully which actions
    are taken in parent clasees ``runHooks()`` methods before adding new acions
    on your own.

    Args:
      verbose (boolean): If method should produce a verbose output.
    """ 
    pass
class HTTPReverseProxy(object):
  portNumber = 8020

  @staticmethod
  def getPort():
    HTTPReverseProxy.portNumber += 1

    # find first free port
    ports = subprocess.check_output(['/bin/netstat', '-lt', '--numeric-ports'])
    while re.search(':' + str(HTTPReverseProxy.portNumber) + ' ', ports) :
      HTTPReverseProxy.portNumber += 1

    return HTTPReverseProxy.portNumber
class Param(object):
  @staticmethod
  def isValidAbsPath(p):
    return not re.search('/../', p) and re.search('^/[-_.a-zA-Z0-9]+$', p)

  @staticmethod
  def isValidRelPath(p):
    return (not (re.search('^/', p) or re.search('^../', p) or re.search('/../', p))) and re.search('^[-/_.a-zA-Z0-9]+$', p)

  @staticmethod
  def isValidFile(p):
    return os.path.isfile(p)

  @staticmethod
  def isValidDir(p):
    return os.path.isdir(p)

  @staticmethod
  def isValidName(p):
    return re.search('^[-_.a-zA-Z0-9]+$', p)

  @staticmethod
  def isValidNumber(p):
    return re.search('^[0-9]+$', str(p))

  @staticmethod
  def isValidDomain(p):
    return re.search('^((([a-z0-9][-a-z0-9]*[a-z0-9])|([a-z0-9]+))[.]?)+$', str(p))

  @staticmethod
  def isValidAlias(p):
    return re.search('^/[-_.a-zA-Z0-9/]+$', str(p))

  @staticmethod
  def isValidHostName(p):
    return re.search('^([-a-zA-Z0-9][.]?)+$', p)

  @staticmethod
  def isValidIP(p):
    return re.search('^[0-9]?[0-9]?[0-9][.][0-9]?[0-9]?[0-9][.][0-9]?[0-9]?[0-9][.][0-9]?[0-9]?[0-9]$', str(p))

class Configuration:
  accounts = None

  def __init__(self):
    self.accounts = []

    for accName in sorted(os.listdir('/home')):
      account = Account(accName)
      account.readConfig()
      self.accounts.append(account)

  def check(self):
    envs = self.findEnvironments([], [], False)
    domains = [i for sublist in [env.getDomains() for env in envs] for i in sublist]
    ports = [i for sublist in [env.getPorts() for env in envs] for i in sublist]
    names = [env.getName() for env in envs]

    duplDomains = [domain for domain, count in collections.Counter(domains).iteritems() if count > 1]
    duplPorts = [port for port, count in collections.Counter(ports).iteritems() if count > 1]
    duplNames = [name for name, count in collections.Counter(names).iteritems() if count > 1]

    for account in self.accounts:
      errors = account.check(duplDomains, duplPorts, duplNames, names)
      if len(errors) > 0 :
        print '  ' + account.name, ': ', errors
        noErrors = False

  def buildImages(self, projects, names, verbose):
    for env in self.findEnvironments(projects, names):
      try:
        env.buildImage(verbose)
      except Exception as e:
        print e

  def runContainers(self, projects, names, verbose):
    for env in self.findEnvironments(projects, names):
      try:
        env.runContainer(verbose)
      except Exception as e:
        print e

  def runHooks(self, projects, names, verbose):
    for env in self.findEnvironments(projects, names):
      try:
        env.runHooks(verbose)
      except Exception as e:
        print e

  def runConsole(self, projects, name, action):
    envs = self.findEnvironments(projects, [name])
    if len(envs) == 1 :
      try:
        if action == 'enter' :
          root = False
        elif action == 'enter-as-root' :
          root = True
        else :
          raise Exception('Unsupported action')
        return envs[0].runConsole(root)
      except Exception as e:
        print '  ' + str(e)
        return
    print "  Given environment not found or not ready"

  def showLogs(self, projects, name):
    envs = self.findEnvironments(projects, [name])
    if len(envs) == 1 :
      return envs[0].showLogs()
    print "  Given environment not found or not ready"

  def clean(self, users, names, verbose):
    for account in self.accounts:
      if len(users) == 0 or users.count(account.name) > 0 :
        account.clean(names, verbose)

  def findEnvironments(self, projects, names, readyOnly = True):
    envs = []
    for account in self.accounts:
      if len(projects) == 0 or projects.count(account.name) > 0 :
        envs += account.findEnvironments(names, readyOnly)
    return envs
class Account:
  base         = '/home'
  name         = ''
  uid          = -1
  gid          = -1
  environments = None
  owner        = False

  def __init__(self, name):
    self.environments = []

    if not Param.isValidName(name) :
      raise Exception('account name contains forbidden characters')
    self.name = name
    path = self.base + '/' + self.name
    if not Param.isValidDir(path) :
      raise Exception('account does not exist')
    self.uid = os.stat(path).st_uid
    self.gid = os.stat(path).st_gid

    self.owner = os.access(path, os.W_OK)
  
  def readConfig(self):
    print '  ' + self.name
    confFileName = self.base + '/' + self.name + '/config.json'
    if os.path.isfile(confFileName):
      try:
        config = json.load(open(confFileName, 'r'))
        self.processConfig(config)
      except Exception as e:
        print '  Configuration file ' + confFileName + ' is not a valid JSON: ' + str(e)

  def processConfig(self, conf):
    if not isinstance(conf, list) :
      raise Exception('configuration is not a list')

    self.environments = []
    for envConf in conf:
      try:
        envConf['BaseDir'] = self.base + '/' + self.name
        envConf['UID']     = self.uid
        envConf['GID']     = self.gid
        envConf['Account'] = self.name
        if 'Type' in envConf :
          if   envConf['Type'] == 'HTTP' :
            env = EnvironmentHTTP(envConf, self.owner)
          elif envConf['Type'] == 'Apache' :
            env = EnvironmentApache(envConf, self.owner)
          elif envConf['Type'] == 'PHP' :
            env = EnvironmentPHP(envConf, self.owner)
          elif envConf['Type'] == 'WSGI3' :
            env = EnvironmentWSGI3(envConf, self.owner)
          elif envConf['Type'] == 'WSGI2' :
            env = EnvironmentWSGI2(envConf, self.owner)
          elif envConf['Type'] == 'Drupal6' :
            env = EnvironmentDrupal6(envConf, self.owner)
          elif envConf['Type'] == 'Generic' :
            env = Environment(envConf, self.owner)
          elif envConf['Type'] == 'noske' :
            env = EnvironmentNoske(envConf, self.owner)
          elif envConf['Type'] == 'noskePatched' :
            env = EnvironmentNoskePatched(envConf, self.owner)
          else :
            raise Exception('environment is of unsupported type (' + envConf['Type'] + ')')
        else :
          raise Exception('environment has no type')
        self.environments.append(env)
      except Exception as e:
        print '  Error in ', (1 + len(self.environments)), ' environment: ', e

  def check(self, duplDomains, duplPorts, duplNames, names):
    errors = {}
    for env in self.environments:
      tmp = env.check(duplDomains, duplPorts, duplNames, names)
      if len(tmp) > 0 :
        errors[env.Name] = tmp
    return errors

  def findEnvironments(self, names, readyOnly = True):
    envs = []
    for env in self.environments:
      if (
        env.owner 
        and (env.ready or readyOnly == False)
        and (len(names) == 0 or names.count(env.Name) > 0) 
      ) :
        envs.append(env)
    return envs

  def clean(self, names, verbose):
    subprocess.call(['sudo', '-u', 'root', 'docker-clean', self.name])
    for env in self.findEnvironments(names):
      env.buildImage(verbose)
      env.runContainer(verbose)
      env.runHooks(verbose)

class Environment(IEnvironment, object):
  DockerImgBase = '/var/lib/docker/images'
  DockerMntBase = '/srv/docker'

  ready         = False
  owner         = False
  Name          = None
  UID           = None
  GID           = None
  BaseDir       = None
  DockerfileDir = None
  Mounts        = None
  Links         = None
  Ports         = None
  Hosts         = None

  def __init__(self, conf, owner):
    self.Mounts = []
    self.Links  = []
    self.Ports  = []
    self.Hosts  = []
    self.owner  = owner

    if not isinstance(conf, dict) :
      raise Exception('configuration is of a wrong type')

    if not 'Account' in conf or not Param.isValidName(conf['Account']) :
      raise Exception('Account name is missing or invalid')
    if not 'Name' in conf or not Param.isValidName(conf['Name']) :
      raise Exception('Name is missing or invalid')
    self.Name = conf['Account'] + '-' + conf['Name']

    if not 'BaseDir' in conf or not Param.isValidDir(conf['BaseDir']) :
      raise Exception('Base dir is missing or invalid')
    self.BaseDir = conf['BaseDir']

    if not 'UID' in conf or not Param.isValidNumber(conf['UID']) :
      raise Exception('UID is missing or invalid')
    self.UID = conf['UID']

    if not 'GID' in conf or not Param.isValidNumber(conf['GID']) :
      raise Exception('GID is missing or invalid')
    self.GID = conf['GID']

    if (
      not 'DockerfileDir' in conf
      or not isinstance(conf['DockerfileDir'], basestring) 
      or self.owner and (
        not Param.isValidRelPath(conf['DockerfileDir'])
        or not (
          Param.isValidFile(self.BaseDir + '/' + conf['DockerfileDir'] + '/Dockerfile') 
          or Param.isValidFile(self.DockerImgBase + '/' + conf['DockerfileDir'] + '/Dockerfile')
        )
      )
    ) :
      raise Exception('DockerfileDir is missing or invalid')
    self.DockerfileDir = conf['DockerfileDir']

    if 'Mounts' in conf and self.owner:
      self.processMounts(conf['Mounts'])

    if 'Links' in conf and self.owner:
      self.processLinks(conf['Links'])

    if 'Ports' in conf :
      self.processPorts(conf['Ports'])

    if 'Hosts' in conf :
      self.processHosts(conf['Hosts'])

  def processMounts(self, conf):
    if not isinstance(conf, list):
      conf = [conf]

    for mount in conf:
      if not isinstance(mount, dict) :
        raise Exception(str(len(self.mounts) + 1) + ' mount point description is not a dictionary')
      if (
        not 'Host' in mount  
        or not (Param.isValidRelPath(mount['Host']) or Param.isValidAbsPath(mount['Host']))
        or not (Param.isValidDir(self.BaseDir + '/' + mount['Host']) or Param.isValidFile(self.BaseDir + '/' + mount['Host']))
      ) :
        raise Exception(str(len(self.Mounts) + 1) + ' mount point host mount point is missing or invalid')
      if not 'Guest' in mount :
        raise Exception(str(len(self.Mounts) + 1) + ' mount point guest mount point is missing')
      if not 'Rights' in mount or (mount['Rights'] != 'ro' and mount['Rights'] != 'rw') :
        raise Exception(str(len(self.Mounts) + 1) + ' mount point access rights are missing or invalid')
      self.Mounts.append(mount)

  def processLinks(self, conf):
    if not isinstance(conf, list) :
      conf = [conf]

    for link in conf :
      if not isinstance(link, dict) :
        raise Exception(str(len(self.Links) + 1) + ' link definition is not a dictionary')
      if not 'Name' in link or not isinstance(link['Name'], basestring) :
        raise Exception(str(len(self.Links) + 1) + ' link container name is missing or invalid')
      if not 'Alias' in link or not isinstance(link['Alias'], basestring) :
        raise Exception(str(len(self.Links) + 1) + ' link alias is missing or invalid')
      self.Links.append(link)

  def processPorts(self, conf):
    if not isinstance(conf, list) :
      conf = [conf]

    for port in conf:
      if not isinstance(port, dict) :
        raise Exception(str(len(self.Ports) + 1) + ' port forwarding description is not a dictionary')
      if not 'Type' in port or not port['Type'] in ['HTTP', 'tunnel'] :
        raise Exception(str(len(self.Ports) + 1) + ' port forwarding type is missing or invalid')
      if not 'Host' in port or not Param.isValidNumber(port['Host']) or int(port['Host']) < 1000 or int(port['Host']) > 65535 :
        if 'Host' in port and port['Type'] == 'HTTP' and int(port['Host']) == 0 :
          port['Host'] = HTTPReverseProxy.getPort()
        else :
          raise Exception (str(len(self.Ports) + 1) + ' port forwarding host port is missing or invalid')
      if not 'Guest' in port or not Param.isValidNumber(port['Guest']) or int(port['Guest']) < 1 or int(port['Guest']) > 65535 :
        raise Exception(str(len(self.Ports) + 1) + ' port forwarding guest port is missing or invalid')
      if port['Type'] == 'HTTP' :
        if not 'ws' in port :
          port['ws'] = []
        if not isinstance(port['ws'], list) :
          port['ws'] = [ port['ws'] ]
        for ws in port['ws']:
          if not isinstance(ws, basestring) or not Param.isValidAlias(ws) :
            raise Exception(str(len(self.Ports) + 1) + ' port forwarding websockets paths are invalid')
      self.Ports.append(port)

  def processHosts(self, conf):
    if not isinstance(conf, list) :
      conf = [conf]

    for host in conf:
      if not isinstance(host, dict) :
        raise Exception(str(len(self.Hosts) + 1) + ' host name definition is not a directory')
      if not 'Name' in host or not Param.isValidHostName(host['Name']) :
        raise Exception(str(len(self.Hosts) + 1) + ' host name definition - host name is missing or invalid ')
      if not 'IP' in host or not Param.isValidIP(host['IP']) :
        raise Exception(str(len(self.Hosts) + 1) + ' host name definition - IP number is missing or invalid ')
      self.Hosts.append(host)

  def check(self, duplDomains, duplPorts, duplNames, names):
    errors = []
    if self.Name in duplNames :
      errors.append('Duplicated name: ' + self.Name)
    for port in self.Ports:
      if port['Host'] in duplPorts :
        errors.append('Port ' + str(port) + ' is duplicated')
    for link in self.Links:
      if not link['Name'] in names :
        errors.append('Alias container ' + link['Name'] + ' does not exist')
    if len(errors) == 0 :
      self.ready = True
    return errors

  def buildImage(self, verbose):
    if not self.owner :
      raise Exception('Must be environment owner to build an image')
    if not self.ready :
      raise Exception('Environment is not ready - it was not checked or there were errord during check')

    if Param.isValidFile(self.BaseDir + '/' + self.DockerfileDir + '/Dockerfile') :
      dockerfileDir = self.BaseDir + '/' + self.DockerfileDir
    elif Param.isValidFile(self.DockerImgBase + '/' + self.DockerfileDir + '/Dockerfile') : 
      dockerfileDir = self.DockerImgBase + '/' + self.DockerfileDir
    else :
      env.ready = False
      raise Exception('There is no Dockerfile ' + self.DockerfileDir + ' ' + self.BaseDir)

    print '  ' + self.Name
    self.runProcess(['docker', 'build', '--force-rm=true', '-t', 'acdh/' + self.Name, dockerfileDir], verbose, '', 'Build failed')

  def runContainer(self, verbose):
    if not self.owner :
      raise Exception('Must be environment owner to run a container')
    if not self.ready :
      raise Exception('Environment is not ready - it was not checked or there were errord during check/build')

    print '  ' + self.Name
    # remove
    self.runProcess(['docker', 'rm', '-f', '-v', self.Name], verbose, '    Removing old container...', None)
    # run
    self.runProcess(['docker', 'run', '--name', self.Name] + self.getDockerOpts() + ['acdh/' + self.Name], verbose, '    Creating container...', 'Container creation failed')
    # mount exported volumes
    self.runProcess(['sudo', '-u', 'root', 'docker-mount-volumes', '-v', '-c', self.Name], verbose, '', None)
    # create systemd script
    self.runProcess(['sudo', '-u', 'root', 'docker-register-systemd', self.Name], verbose, '    Registering in systemd', 'Systemd script creation failed')

  def runHooks(self, verbose):
    if not self.owner :
      raise Exception('Must be environment owner to run hooks')

    print '  ' + self.Name

    # register system user and group for UID and GID used in host
    cmd =  'echo "user:x:' + str(self.UID) + ':' + str(self.GID) + '::' + self.getGuestHomeDir() + ':/bin/bash" >> /etc/passwd ;'
    cmd += 'echo "user:x:' + str(self.GID) + ':" >> /etc/group ;'
    cmd += 'echo "user:*:16231:0:99999:7:::" >> /etc/shadow'
    self.runProcess(['docker', 'exec', self.Name, 'bash', '-c', cmd], verbose, '    Registering user', None)

  def runConsole(self, root):
    if not self.ready :
      return False

    args = ['docker', 'exec', '-ti', '-u', 'root', self.Name, '/bin/bash']
    if not root :
      args[4] = 'user'
    subprocess.call(args)

  def showLogs(self):
    if not self.ready :
      raise Exception('Environment is not ready - it was not checked or there were errord during check')

    subprocess.call(['docker', 'logs', self.Name])

  def runProcess(self, args, verbose, header, errorMsg):
    proc = None
    if verbose :
      print header
      ret = subprocess.call(args)
    else :
      proc = subprocess.Popen(args, stdout = subprocess.PIPE, stderr = subprocess.PIPE)
      out, err = proc.communicate()
      ret = proc.returncode

    if ret != 0 and not errorMsg is None:
      self.ready = False
      if not proc is None:
        print out + '\n' + err
      raise Exception(errorMsg)
    return ret

  def getName(self):
    return self.Name

  def getPorts(self):
    ports = []
    for port in self.Ports:
      ports.append(port['Host'])
    return ports

  def getDomains(self):
    return []

  def getDockerOpts(self):
    dockerOpts = ['-d']
    for mount in self.Mounts:
      dockerOpts += ['-v',  self.BaseDir + '/' + mount['Host'] + ':' + mount['Guest'] + ':' + mount['Rights']]
    for port in self.Ports:
      dockerOpts += ['-p', str(port['Host']) + ':' + str(port['Guest'])]
    for link in self.Links:
      dockerOpts += ['--link', link['Name'] + ':' + link['Alias']]
    for host in self.Hosts:
      dockerOpts += ['--add-host', host['Name'] + ':' + host['IP']]
    return dockerOpts

  def getGuestHomeDir(self):
    return '/'

class EnvironmentHTTP(Environment, IEnvironment):
  ServerName    = None
  ServerAlias   = None
  HTTPS         = True

  def __init__(self, conf, owner):
    self.ServerAlias = []
    super(EnvironmentHTTP, self).__init__(conf, owner)

    if 'ServerName' in conf and Param.isValidDomain(conf['ServerName']) :
      self.ServerName = conf['ServerName']

    if 'ServerAlias' in conf:
      self.processServerAlias(conf['ServerAlias'])

    if 'HTTPS' in conf :
      if not isinstance(conf['HTTPS'], basestring) or not ['true', 'false'].count(conf['HTTPS']) > 0 :
        raise Exception('HTTPS is not a string or has value other then true/false')
      self.HTTPS = True if conf['HTTPS'] == 'true' else False

  def processServerAlias(self, conf):
    if not isinstance(conf, list):
      if not isinstance(conf, basestring):
        raise Exception('ServerAlias is not a string nor list')
      conf = [conf]

    for alias in conf:
      if not Param.isValidDomain(alias) :
        raise Exception(alias + ' is not a valid domain')
    self.ServerAlias = conf

  def check(self, duplDomains, duplPorts, duplNames, names):
    errors = super(EnvironmentHTTP, self).check(duplDomains, duplPorts, duplNames, names)
    if self.ServerName in duplDomains :
      errors.append('Domain ' + self.serverName + ' is duplicated')
    for alias in self.ServerAlias:
      if alias in duplDomains :
        errors.append('ServerAlias ' + alias + ' is duplicated')
    if len(errors) == 0 :
      self.ready = True
    else :
      self.ready = False
    return errors

  def runHooks(self, verbose):
    super(EnvironmentHTTP, self).runHooks(verbose)
    self.configureProxy(verbose)

  def configureProxy(self, verbose):
    if verbose :
      print '    Setting up reverse proxy'

    HTTPPort = self.getHTTPPort()
    websockets = ''
    for ws in HTTPPort['ws']:
      websockets += 'ProxyPass        ' + ws + ' ws://127.0.0.1:' + str(HTTPPort['Host']) + ws + '\n'
      websockets += 'ProxyPassReverse ' + ws + ' ws://127.0.0.1:' + str(HTTPPort['Host']) + ws + '\n'
    proc = subprocess.Popen(['sudo', '-u', 'root', 'docker-register-proxy', self.Name, self.ServerName, self.getServerAlias(), str(HTTPPort['Host']), websockets, 'true' if self.HTTPS else 'false'])
    out, err = proc.communicate()

  def getDockerOpts(self):
    dockerOpts = super(EnvironmentHTTP, self).getDockerOpts()
    return dockerOpts

  def getDomains(self):
    domains = []
    if not self.ServerName is None :
      domains.append(self.ServerName)
    domains += self.ServerAlias
    return domains

  def getServerAlias(self):
    serverAlias = self.ServerName
    for alias in self.ServerAlias:
      serverAlias += ' ' + alias
    return serverAlias

  def getHTTPPort(self):
    for port in self.Ports:
      if port['Type'] == 'HTTP' :
        return port
    raise Exception('No HTTP port')

class EnvironmentApache(EnvironmentHTTP, IEnvironment):
  DocumentRootMount  = '/var/www/html'
  DocumentRoot       = None
  AllowOverride      = 'All'
  Options            = 'None'
  Aliases            = None

  def __init__(self, conf, owner):
    self.Aliases = []
    if 'DockerfileDir' not in conf :
      conf['DockerfileDir'] = 'http_http'
    super(EnvironmentApache, self).__init__(conf, owner)
    self.Ports = [{ "Host" : HTTPReverseProxy.getPort(), "Guest" : 80 , "Type" : "HTTP", "ws" : []}]

    if not Param.isValidDomain(self.ServerName) :
      raise Exception('ServerName is missing or invalid')

    if (
      not 'DocumentRoot' in conf 
      or self.owner and (
        not Param.isValidRelPath(conf['DocumentRoot'])
        or not Param.isValidDir(self.BaseDir + '/' + conf['DocumentRoot'])
      )
    ) :
      raise Exception('DocumentRoot is missing or invalid')
    self.DocumentRoot = conf['DocumentRoot']
    self.Mounts.append({ "Host" : self.DocumentRoot, "Guest" : self.DocumentRootMount, "Rights" : "rw" })

    if 'AllowOverride' in conf :
      self.processAllowOverride(conf['AllowOverride'])

    if 'Options' in conf :
      self.processOptions(conf['Options'])

    if 'Aliases' in conf :
      self.processAliases(conf['Aliases'])

  def processAllowOverride(self, conf):
    dictionary = ['All', 'AuthConfig', 'FileInfo', 'Indexes', 'Limit', 'Options']
    
    if not isinstance(conf, list):
      if not isinstance(conf, basestring):
        raise Exception('AllowOverride is not a string nor list')
      conf = [conf]

    self.AllowOverride = ''
    for opt in conf:
      dictionary.index(opt)
      self.AllowOverride += ' ' + opt

  def processOptions(self, conf):
    dictionary = ['All', 'ExecCGI', 'FollowSymLinks', 'Includes', 'MultiViews', 'SymLinksIfOwnerMatch']
    
    if not isinstance(conf, list):
      if not isinstance(conf, basestring):
        raise Exception('Options is not a string nor list')
      conf = [conf]

    self.Options = ''
    for opt in conf:
      dictionary.index(opt)
      self.Options += ' ' + opt

  def processAliases(self, conf):
    if not isinstance(conf, list) :
      conf = [conf]

    for alias in conf:
      if not isinstance(alias, dict) :
        raise Exception('Alias definition is not a dictionary')
      if not 'Alias' in alias or not Param.isValidAlias(alias['Alias']) :
        raise Exception('Alias name is missing or invalid')
      if (
        not 'Path' in alias 
        or self.owner and not (
          Param.isValidAbsPath(alias['Path']) 
          or Param.isValidRelPath(alias['Path']) and (
            Param.isValidDir(self.BaseDir + '/' + self.DocumentRoot + '/' + alias['Path']) 
            or Param.isValidFile(self.BaseDir + '/' + self.DocumentRoot + '/' + alias['Path'])
          )
        )
      ) :
        raise Exception('Alias path is missing or invalid')
    self.Aliases = conf

  def runHooks(self, verbose):
    super(EnvironmentApache, self).runHooks(verbose)

    if verbose :
      print '    Configuring Apache in guest'

    self.apacheConfigure()
    self.apacheRestart(verbose)

  def apacheConfigure(self):
    vhFile = self.getApacheVHConfFile()
    vhFile.write(self.guestVHTemplate.format(
      ServerName = self.ServerName,
      ServerAlias = self.getServerAlias(),
      UID = '#' + str(self.UID),
      GID = '#' + str(self.GID),
      DocumentRootMount = self.DocumentRootMount,
      AllowOverride = self.AllowOverride,
      Options = self.Options,
      Aliases = self.getAliases()
    ))
    vhFile.close()

  def apacheRestart(self, verbose):
    self.runProcess(['docker', 'exec', self.Name, 'supervisorctl', 'restart', 'apache2'], verbose, '', 'Apache restart failed')

  def getDockerOpts(self):
    dockerOpts = super(EnvironmentApache, self).getDockerOpts()
    dockerOpts += ['--cap-add=SYS_NICE', '--cap-add=DAC_READ_SEARCH']
    return dockerOpts

  def getApacheVHConfFile(self):
    vhFileName = self.DockerMntBase + '/' + self.Name + '/etc/apache2/sites-enabled/000-default.conf'
    vhFile = open(vhFileName, 'w')
    return vhFile

  def getAliases(self):
    aliases = ''
    for alias in self.Aliases:
      aliases += 'Alias ' + alias['Alias'] + ' ' + self.DocumentRootMount + '/' + alias['Path'] + '\n'
    return aliases

  def getGuestHomeDir(self):
    return '/var/www/html'

  guestVHTemplate = """
<VirtualHost *:80>
  ServerName {ServerName}
  DocumentRoot {DocumentRootMount}
  ServerAlias {ServerAlias}
  AssignUserID {UID} {GID}

  <Directory {DocumentRootMount}>
    Require all granted
    AllowOverride {AllowOverride}
    Options {Options}
  </Directory>

  {Aliases}
</VirtualHost>   
"""

class EnvironmentPHP(EnvironmentApache, IEnvironment):
  def __init__(self, conf, owner):
    if 'DockerfileDir' not in conf :
      conf['DockerfileDir'] = 'http_php'
    super(EnvironmentPHP, self).__init__(conf, owner)

class EnvironmentDrupal7(EnvironmentPHP, IEnvironment):
  def __init__(self, conf, owner):
    if 'DockerfileDir' not in conf :
      conf['DockerfileDir'] = 'http_drupal7'
    super(EnvironmentDrupal6, self).__init__(conf, owner)

class EnvironmentWSGI3(EnvironmentApache, IEnvironment):
  PythonPath      = None
  WSGIScriptAlias = None

  def __init__(self, conf, owner):
    if 'DockerfileDir' not in conf :
      conf['DockerfileDir'] = 'http_wsgi3'
    super(EnvironmentWSGI3, self).__init__(conf, owner)

    if 'PythonPath' in conf :
      self.processPythonPath(conf['PythonPath'])
    else:
      self.PythonPath = [self.DocumentRoot]
    
    if (
      not 'WSGIScriptAlias' in conf 
      or self.owner and (
        not Param.isValidRelPath(conf['WSGIScriptAlias']) 
        or not Param.isValidFile(self.BaseDir + '/' + self.DocumentRoot + '/' + conf['WSGIScriptAlias']) 
      )
    ) :
      raise Exception('WSGIScriptAlias is missing or invalid')
    self.WSGIScriptAlias = conf['WSGIScriptAlias']

  def processPythonPath(self, conf):
    if not isinstance(conf, list):
      if not isinstance(conf, basestring):
        raise Exception('PythonPath is not a string nor list')
      conf = [conf]

    for path in conf:
      if not isinstance(path, basestring) :
        raise Exception('PythonPath element is not a string')
      fullPath = self.BaseDir + '/' + self.DocumentRoot + '/' + path
      if self.owner and (not Param.isValidRelPath(path) or not (Param.isValidDir(fullPath) or Param.isValidFile(fullPath))) :
        raise Exception('PythonPath element is invalid')
    self.PythonPath = conf

  def apacheConfigure(self):
    vhFile = self.getApacheVHConfFile()
    vhFile.write(self.guestVHTemplate.format(
      ServerName = self.ServerName,
      ServerAlias = self.getServerAlias(),
      UID = '#' + str(self.UID),
      GID = '#' + str(self.GID),
      DocumentRootMount = self.DocumentRootMount,
      PythonPath = self.getPythonPath(),
      WSGIScriptAlias = self.DocumentRootMount + '/' + self.WSGIScriptAlias,
      AllowOverride = self.AllowOverride,
      Options = self.Options,
      Aliases = self.getAliases()
    ))
    vhFile.close()

  def getPythonPath(self):
    pythonPath = ''
    for path in self.PythonPath:
      pythonPath += ':' + self.DocumentRootMount + '/' + path
    return pythonPath[1:]

  guestVHTemplate = """
<VirtualHost *:80>
  ServerName {ServerName}
  ServerAlias {ServerAlias}
  DocumentRoot {DocumentRootMount}

  WSGIDaemonProcess {ServerName} user={UID} group={GID} python-path={PythonPath}
  WSGIProcessGroup {ServerName}
  WSGIScriptAlias / {WSGIScriptAlias}

  <Directory {DocumentRootMount}>
    Require all granted
    AllowOverride {AllowOverride}
    Options {Options}
  </Directory>

  {Aliases}
</VirtualHost>
"""

class EnvironmentWSGI2(EnvironmentWSGI3, IEnvironment):
  def __init__(self, conf, owner):
    if 'DockerfileDir' not in conf :
      conf['DockerfileDir'] = 'http_wsgi2'
    super(EnvironmentWSGI2, self).__init__(conf, owner)

from distutils import dir_util
import subprocess

class EnvironmentNoske(EnvironmentHTTP, IEnvironment):
  DataPath = 'data'
  BonitoPath = 'bonito'
  RegistryPath = 'registry'

  def __init__(self, conf, owner):
    if 'DockerfileDir' not in conf :
      conf['DockerfileDir'] = 'noske'
    super(EnvironmentNoske, self).__init__(conf, owner)
    self.Mounts.append({"Host" : self.BaseDir + '/' + self.DataPath, "Guest" : "/data", "Rights" : "ro"})
    self.Ports = [{ "Host" : HTTPReverseProxy.getPort(), "Guest" : 80 , "Type" : "HTTP", "ws" : []}]

    #TODO It would be nice to allow users to provide DataPath, BonitoPath and RegistryPath through the conf variable
    # Of course values provided by the user should be checked - the Param class provides useful methods to perform such checks

  def runHooks(self, verbose):
    super(EnvironmentNoske, self).runHooks(verbose)

    #TODO we should rather use self.runProcess() instead of subprocess.call() to handle verbose flag and error handling in an easy way
    subprocess.call(['docker', 'exec', self.Name, 'chown', 'user:user', '-R', '/usr/lib/python2.7/dist-packages/bonito'])
    dir_util.copy_tree(self.BaseDir + '/' + self.BonitoPath, self.DockerMntBase + '/' + self.Name + '/usr-lib-python2.7-dist-packages-bonito')
    subprocess.call(['docker', 'exec', self.Name, 'chown', 'user:user', '-R', '/usr/lib/python2.7/dist-packages/bonito'])
    subprocess.call(['docker', 'exec', self.Name, 'chmod', '+rX', '-R', '/usr/lib/python2.7/dist-packages/bonito'])
    subprocess.call(['docker', 'exec', self.Name, 'python', '-m', 'compileall', '/usr/lib/python2.7/dist-packages/bonito']) 

    subprocess.call(['docker', 'exec', self.Name, 'chown', 'user:user', '-R', '/var/lib/manatee/registry/'])
    dir_util.copy_tree(self.BaseDir + '/' + self.RegistryPath, self.DockerMntBase + '/' + self.Name + '/var-lib-manatee-registry/')
    subprocess.call(['docker', 'exec', self.Name, 'chown', 'user:user', '-R', '/var/lib/manatee/registry/'])
    subprocess.call(['docker', 'exec', self.Name, 'chmod', '+rX', '-R', '/var/lib/manatee/registry/'])
parser = argparse.ArgumentParser(description='Script for maintiaining docker images and containers')
parser.add_argument('-p', '--project', action = 'append', nargs = '*', required = False, help = 'Project whose environments should be processed')
parser.add_argument('-e', '--environment', action = 'append', nargs = '*', required = False, help = 'Names of environments to proccess')
parser.add_argument('-a', '--action', action = 'store', nargs = 1, required = False, choices = ['check', 'build', 'run', 'clean', 'enter-as-root', 'enter', 'logs'],  help = 'Action to perform')
parser.add_argument('-v', '--verbose', action = 'store_true', required = False,  help = 'Enable verbose output')
args = parser.parse_args()
if args.project is None :
  args.project = [[]]
args.project = reduce(lambda x, y: x + y, args.project)
if args.environment is None :
  args.environment = [[]]
args.environment = reduce(lambda x, y: x + y, args.environment)

print 'Loading config...'
configuration = Configuration()

print 'Checking conflicts between environments...'
configuration.check()

for i in configuration.findEnvironments([], [], True):
  print i.Name + ' ' + str(i.ready)
  
if args.action is None or args.action.count('build') > 0 :
  print 'Building images...'
  configuration.buildImages(args.project, args.environment, args.verbose)

if args.action is None or args.action.count('run') > 0 :
  print 'Running containers...'
  configuration.runContainers(args.project, args.environment, args.verbose)

  print 'Running hooks...'
  # give container(s) time to start before executing hooks
  time.sleep(5)
  configuration.runHooks(args.project, args.environment, args.verbose)

if not args.action is None and args.action.count('clean') > 0 :
  configuration.clean(args.project, args.environment, args.verbose)

if not args.action is None :
  if len(args.action) != 1 :
    print "  Please choose exactly one environment"
  else:
    if   args.action.count('enter-as-root') > 0 or args.action.count('enter') > 0 :
      print 'Running console...'
      configuration.runConsole(args.project, args.environment[0], args.action[0])
    elif args.action.count('logs') > 0 :
      print 'Printing logs...'
      configuration.showLogs(args.project, args.environment[0])

